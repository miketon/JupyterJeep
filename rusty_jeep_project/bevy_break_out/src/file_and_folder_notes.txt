use bevy::prelude::*;
// - `crate::` is used to refer to the root of the current crate as opposed to
// - `super::` which refers to the parent module
// @note : In this case, `crate::` is used to access the `GameState` enum from
// `game_state` module in game_state.rs (which is in the same directory as this)
// In the original example/game_menu.rs all code was in one monolithic file, so
// `super::` was used to refer to the parent module
use crate::game_state::GameState;


--[ main.rs ]-----------------------------------------------------------------

// why so I need to import this here when it's not directly used in this file?
// - but is used in splash.rs and menu.rs
mod bundles;

-- [ gpt ] --------------------------------------------------------------------
In Rust, the `mod` keyword is used to declare a module within your code. By  
declaring a module in your `main.rs` (or `lib.rs`) file, you are telling the  
Rust compiler to include and compile the code from the respective files  
(e.g., `game_state.rs`, `menu.rs`, `splash.rs`, and `asset_bundles.rs`). 

Even though `asset_bundles` is not directly used in `main.rs`, you still need to  
declare it as a module to ensure that the Rust compiler includes it when  
compiling the project. When you declare the `asset_bundles` module in `main.rs`,  
you create a hierarchy of modules that are accessible within your crate.

Since `splash.rs` and `menu.rs` use `asset_bundles`, you need to ensure that  
the `asset_bundles` module is compiled and available for those modules to  
access. By declaring `mod asset_bundles;` in `main.rs`, you make the  
`asset_bundles` module part of the crate's module hierarchy, allowing other  
modules (like `splash` and `menu`) to import and use code from it.

In summary, you need to declare all the modules in your `main.rs` (or `lib.rs`)  
file to create a module hierarchy and tell the Rust compiler to include and  
compile the code from those files, even if they are not directly used in  
`main.rs`.